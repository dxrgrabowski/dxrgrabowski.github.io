<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>smallest-asm-program</title>
      <link href="/2024/09/17/smallest-asm-program/"/>
      <url>/2024/09/17/smallest-asm-program/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>As we saw recently when trying to create the shortest C program. The biggest cost in this program was glibc and its overhead for running the program. How is it look like in the case of asm? Today we will see.</p><p>I know how scary assembly is if you‚Äôve only heard about it. But it‚Äôs not as scary as they say. I‚Äôll present everything in a very simple way so that everyone can understand what‚Äôs going on and what‚Äôs responsible for what.</p><p>To fully understand what is happening first I will tell you what is syscall.<br>By default, programs run in user mode, which is a restricted execution environment where the program cannot directly access hardware resources. In user mode, a program does not have direct access I&#x2F;O operations, network access, managing system processes or system files. To interact with it programs need to communicate with the kernel via kernel mode. A system call (syscall) is the mechanism by which a program running in user mode requests services from the kernel. e.g. <em>write()</em> used in <em>prinf()</em> to access stdout or <em>exit()</em> to exit process. More details and determining the moment at which we switch between modes later in this article.</p><p>I will use <em>sys_write</em> and <em>write()</em> to differentiate between the real syscall and glibc function call.</p><p>I think now is a good moment to reveal that we can compile a C file without glibc that can be done with flag <code>-nostdlib</code> the fact is, that this program will not be simmilar to C.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov $60, %rax\n&quot;</span>  </span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov $0, %rdi\n&quot;</span>  </span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And its perf:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.06</span>   msec task-clock:u            #    <span class="number">0.284</span> CPUs utilized</span><br><span class="line"><span class="number">1</span>      page-faults:u                #    <span class="number">16.743</span> K/sec</span><br><span class="line"><span class="number">1119</span>   cycles:u                     #    <span class="number">0.018</span> GHz</span><br><span class="line"><span class="number">5</span>      stalled-cycles-frontend:u    #    <span class="number">0.45</span>% frontend cycles idle</span><br><span class="line"><span class="number">0</span>      stalled-cycles-backend:u     </span><br><span class="line"><span class="number">6</span>      instructions:u               #    <span class="number">0.01</span>  insn per cycle</span><br></pre></td></tr></table></figure><p>As we can see the result is much better than the last C static linked program, thats because we don‚Äôt need glibc anymore. </p><p>Now time for some assembly which will explain us what happened above:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start <span class="comment">// Inform the linker where is program start</span></span><br><span class="line"></span><br><span class="line">_start<span class="punctuation">:</span>           <span class="comment">// Program start</span></span><br><span class="line">    mov rax<span class="punctuation">,</span> <span class="number">60</span>   <span class="comment">// syscall number for exit (60)</span></span><br><span class="line">    mov rdi<span class="punctuation">,</span> <span class="number">0</span>    <span class="comment">// set exit code 0 (rdi = 0)</span></span><br><span class="line">    syscall       <span class="comment">// invoke the system call with syscall number -</span></span><br><span class="line">                  <span class="comment">// stored in rax and exit code in rdi</span></span><br></pre></td></tr></table></figure><p>This is <span class="reveal-text" before="x86-64" after="64 bit"></span> architecture, this is important because code and syscall codes on <span class="reveal-text" before="x86" after="32 bit"></span> are different :D</p><details>  <summary><span style="color:rgb(0, 152, 241)">How it would look on x86</span></summary><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start <span class="comment">// Infrom the linker where is program start</span></span><br><span class="line"></span><br><span class="line">_start<span class="punctuation">:</span>            </span><br><span class="line">    mov rax<span class="punctuation">,</span> <span class="number">1</span>   </span><br><span class="line">    mov rdi<span class="punctuation">,</span> <span class="number">0</span>    </span><br><span class="line">    int <span class="number">0x80</span>       </span><br></pre></td></tr></table></figure>By calling *int 0x80* you invoke interrupt and go to x80 address in interrupt handler tablethe 0x80 == 128 is special interrupt programmed only for program system calls</details><details>  <summary><span style="color:rgb(0, 152, 241)">How this code became executable</span></summary>Unless like in C's gcc going through pre-processing, compiling, assembling and linking.Assembly doesn't need to be pre-processed or compiled. On linux you can use <span class="reveal-text" before="NASM" after="Netwide Assembler"></span> or <span class="reveal-text" before="AS" after="GNU Assembler"></span> as a assembling tool.I used:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf64 -o exit.o exit.asm </span><br></pre></td></tr></table></figure>where elf64 is format of object file it could be win32The next step is linking <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld exit.o -o exit</span><br></pre></td></tr></table></figure>which is resolving symbols relocating adresses from relative to absolute and making final excutable format, sets up the entry point, the sections (text, data, etc.), and the memory layout necessary for the operating system to run the program.</details><p>The syscall instruction invokes the syscall with the code contained in the rax register. Then, depending on the code, arguments are required, which are successively passed in rdi, rsi, rdx, r10, r8, r9, this is the convention adopted. <a href="https://x64.syscall.sh/">here</a> you can find list of all syscalls on x86-64 to see how it look like.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.10</span>   msec task-clock:u            #    <span class="number">0.257</span> CPUs utilized</span><br><span class="line"><span class="number">1</span>      page-faults:u                #    <span class="number">9.980</span> K/sec</span><br><span class="line"><span class="number">1289</span>   cycles:u                     #    <span class="number">0.013</span> GHz</span><br><span class="line"><span class="number">5</span>      stalled-cycles-frontend:u    #    <span class="number">0.39</span>% frontend cycles idle</span><br><span class="line"><span class="number">0</span>      stalled-cycles-backend:u</span><br><span class="line"><span class="number">4</span>      instructions:u               #    <span class="number">0.00</span>  insn per cycle</span><br></pre></td></tr></table></figure><h2 id="Understanding-Program-Execution-in-UNIX-like-Systems"><a href="#Understanding-Program-Execution-in-UNIX-like-Systems" class="headerlink" title="Understanding Program Execution in UNIX-like Systems"></a>Understanding Program Execution in UNIX-like Systems</h2><p>In UNIX-like systems, programs start execution from the <em>_start</em> function, not the <em>main()</em> function, as we are accustomed to in C. The <em>main()</em> function is essentially a wrapper, like many other components in C. Somewhere within <em>_start</em>, the <em>__libc_start_main</em> function is invoked, followed by a call to main. Here‚Äôs a simplified visualization of this process:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_start<span class="punctuation">:</span></span><br><span class="line">    <span class="comment">// rdi already contains argc (passed by kernel)</span></span><br><span class="line">    <span class="comment">// rsi already contains argv (passed by kernel)</span></span><br><span class="line">    <span class="comment">// stack already aligned somewhere</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call main handler</span></span><br><span class="line">    call __libc_start_main</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exit</span></span><br><span class="line">    mov rdi<span class="punctuation">,</span> rax  <span class="comment">// Use main&#x27;s return value as exit status</span></span><br><span class="line">    mov rax<span class="punctuation">,</span> <span class="number">60</span>   <span class="comment">// syscall number for exit</span></span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>If you‚Äôre wondering how the return value ends up in the rax register, it‚Äôs due to the <a href="https://wiki.osdev.org/System_V_ABI">System V ABI calling convention</a>. This convention dictates how functions pass arguments and return values between each other and the operating system.</p><h2 id="Do-All-Programs-Need-an-Exit"><a href="#Do-All-Programs-Need-an-Exit" class="headerlink" title="Do All Programs Need an Exit?"></a>Do All Programs Need an Exit?</h2><p>What happens if there is no exit system call? Without an explicit exit, the instruction pointer would jump to the next address, fetch the next memory block, and attempt to decode and execute it. This would likely result in a segmentation fault, as the memory would not contain valid executable instructions.</p><p>You might wonder why in C you can write <code>int main()&#123;&#125;</code> without explicitly returning a value or even use <code>void main()&#123;&#125;</code> (which is still accepted for backward compatibility). Surprisingly, the program will compile and execute correctly.</p><p>If you don‚Äôt provide a return value, the glibc implicitly exits with 0 code. This behavior is evident when using <em>void main()</em>, we see exit call is present:<br><img src="/2024/09/17/smallest-asm-program/main_no_return.png" alt="alt text"></p><h3 id="ret-or-sys-exit"><a href="#ret-or-sys-exit" class="headerlink" title="ret or sys_exit"></a>ret or sys_exit</h3><p>The _start function is the entry point, at least for statically linked programs, for dynamically linked programs (if dynamic loader performs C&#x2F;C++&#x2F;Objective-C startup initialization by including the entry point from crt1.o) it could be the dynamic linker itself. But what is always the same is Initial Process Stack.<br><img src="https://i.sstatic.net/XiiyH.png" alt="alt text"><br>Ret moves instruction pointer to a return address on the stack which doesn‚Äôt exist here, so calling ret from _start surely will cause segfault. ret can be called from main (because a new stack frame was created by calling this function) sys_exit or exit() can also be called which will prevent us from returning to _start.</p><h2 id="glibc‚Äôs-Role"><a href="#glibc‚Äôs-Role" class="headerlink" title="glibc‚Äôs Role"></a>glibc‚Äôs Role</h2><p>Saying that three lines of assembly eliminate redundancy in glibc misses the broader context. Glibc acts as an intermediary, making system calls like <em>sys_write</em> easier to use by providing wrappers like direct <em>write()</em> or indirect <em>printf()</em>. It handles details like register saving&#x2F;restoring. While direct assembly skips everything, glibc flushing stdout, thread management, and other necessary actions before the final program exit, aremaking it much more than just ‚Äúredundant code.‚Äù Skipping these operations could lead to undefined behavior or even program crashes.</p><p>For example, after calling the <em>write()</em>, the program needs to continue executing correctly, so it‚Äôs essential to restore the registers to avoid overwriting critical data. This isn‚Äôt necessary for <em>sys_exit</em> because it clobbers some of registers an changes context anyway, it‚Äôs crucial for other syscalls where the program continues running.</p><p>There is  also syscall(), a small library function that invokes the system call whose assembly language interface has the specified number with the specified arguments.  Employing syscall() is useful, for example, when invoking a system call that has no wrapper function in the C library. It provides saving, restoring registers and returning an error which is always a better solution than a syscall in direct Assembly.</p><h3 id="Glibc-glibc-libc-is-there-sth-other"><a href="#Glibc-glibc-libc-is-there-sth-other" class="headerlink" title="Glibc, glibc, libc is there sth other?"></a>Glibc, glibc, libc is there sth other?</h3><p><a href="https://musl.libc.org/">Musl</a> is a smaller alternative to glibc (7x smaller), and it‚Äôs more common to see inline assembly syscalls used there. However, glibc‚Äôs complexity supports more features, safer execution. Hope I‚Äôll write something more about it someday.</p><h2 id="Vicious-circle"><a href="#Vicious-circle" class="headerlink" title="Vicious circle"></a>Vicious circle</h2><p>What‚Äôs funny is that glibc itself is not able to call any syscall using C, because it doesn‚Äôt have direct access to registers, for that you need an assembler, which will probably be somewhere in the depths of glibc. Calling syscall in assembly causes an interrupt, the system goes into kernel mode and uses IDT to determine how to process a specific interrupt, finally the interrupt goes to entry_64.S, which will pass control to the appropriate handler written in C via syscall_table, where there is usually something like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>Then the appropriate function, e.g. sys_write, can be used. As you can see, it goes full circle C-&gt;assembly-&gt;C where returning of syscall code will look simillarly with sysret called in assembly.</p><h2 id="sth-else"><a href="#sth-else" class="headerlink" title="sth else"></a>sth else</h2><p>Today, going down to assembly is rarely justified when embedded devices have developed so much, where memory is no longer so limited, and clock speeds have increased so much that time is also no longer an issue. However, it is always worth being aware of how it works ‚Äúunder the hood‚Äù.</p><p>In this article I used the expressions ‚Äúprocess‚Äù and ‚Äúprogram‚Äù quite interchangeably, in this context it did not have a very big meaning, but it will gain importance in my next article in which I will discuss how threads are created, what is clone() fork() exceve() or pthread_create().</p><p>or </p><p>I really appreciate the criticism, so if you have any reservations, leave a comment ‚¨áÔ∏è</p>]]></content>
      
      
      <categories>
          
          <category> Operating System Construction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
            <tag> C </tag>
            
            <tag> gcc </tag>
            
            <tag> libc </tag>
            
            <tag> perf </tag>
            
            <tag> syscall </tag>
            
            <tag> process </tag>
            
            <tag> linker </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How many clock cycles cpu need to execute smallest program in C</title>
      <link href="/2024/09/07/smallest-program/"/>
      <url>/2024/09/07/smallest-program/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>I was wondering how big overhead is before or&#x2F;and after program execution. It was unreasonable to start with anything other than the program with blank main:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><p>Theoretically it is possible to compile a void main in C, we would get rid of the value return. But that is not valid with ISO standard(<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">C++ ¬ß3.6.1&#x2F;2</a> | <a href="https://www.open-std.org/JTC1/sc22/WG14/www/docs/n2310.pdf">C ¬ß5.1.2.2&#x2F;1</a>). So we will skip it.</p><p>When when we try to disassembly such code we get assembly with 5 instructions</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push    rbp      <span class="comment">// push base pointer on stack to stabilize stack frame</span></span><br><span class="line">mov     rbp, rsp <span class="comment">// set base pointer on local stack pointer</span></span><br><span class="line">mov     eax, <span class="number">1</span>   <span class="comment">// eax commonly stores the function return value set it to 1</span></span><br><span class="line">pop     rbp      <span class="comment">// close the stack frame</span></span><br><span class="line">ret              <span class="comment">// return form procedure</span></span><br></pre></td></tr></table></figure><p>technically speaking, stack and stack pointers operations are not needed in this context so code could be reduced to</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, <span class="number">1</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Now guess how many instructions it takes to execute the above program. The answer is <span class="reveal-text" before="???" after="110 000"></span>.<br>This value is unbelievable to imagine considering that the program itself is 5 instructions. We will try to find out what and why causes this.</p><p>Mainly two tools will be used for the analysis <code>valgrind --tool=callgrind</code> and <code>perf</code>.<br>For visualization I will be using callgrind because of its tool gui and greater clarity of results. As most important factor I picked instruction count because it is most machine independent and deterministic. The run environment does not have to be <span class="reveal-text" before="hermetic|isolated " after="RTOS :D"></span> to perform a profilling which is not true for cycles and especially execution time.<br><img src="/2024/09/07/smallest-program/callgrind_graph_1.png" alt="callgrind call map"><br><img src="/2024/09/07/smallest-program/callgrind_list_1.png" alt="callgrind call list"><br>As we can see 98.22% instructions were made outside of prog, in ld-linux-x86-64.so which is dynamic linux linker <span class="reveal-text" before="DLL" after="dynamic library"></span> we can see methods like <em>_dl_sysdep_start</em>, <em>dl_start</em>, <em>dl_main</em>, <em>dl_relocate_object</em>, <em>dl_lookup_symbol_x</em> they are part of this process. Their goal is to load, init, relocate and <span class="reveal-text" before="resolve symbols" after="find function and variables names"></span> used in prog contained for example from libc.so. Later we can see <em>handle_amd</em> or <em>handle_intel</em> they are involved in initialization and detection of specific processor functions (like SSE extension support, AVX, etc.) Even if your program does not use these functions directly, the system must initialize the CPU to adapt to the appropriate hardware environment. At the end let‚Äôs run <code>perf stat</code> to have some unified result to compare it later</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.42</span>    msec task-clock:u              #  <span class="number">0.571</span> CPUs utilized</span><br><span class="line"><span class="number">48</span>      page-faults:u                  #  <span class="number">115.551</span> K/sec</span><br><span class="line"><span class="number">331515</span>  cycles:u                       #  <span class="number">0.798</span> GHz</span><br><span class="line"><span class="number">16380</span>   stalled-cycles-frontend:u      #  <span class="number">4.94</span>% frontend cycles idle</span><br><span class="line"><span class="number">1911</span>    stalled-cycles-backend:u       #  <span class="number">0.58</span>% backend cycles idle</span><br><span class="line"><span class="number">112047</span>  instructions:u                 #  <span class="number">0.34</span>  insn per cycle</span><br><span class="line">                                       #  <span class="number">0.15</span>  stalled cycles per insn</span><br><span class="line"><span class="number">22072</span>   branches:u                     #  <span class="number">53.134</span> M/sec</span><br><span class="line"><span class="number">1830</span>    branch-misses:u                #  <span class="number">8.29</span>% of all branches</span><br><span class="line"></span><br><span class="line"><span class="number">0.000727095</span> seconds time elapsed</span><br></pre></td></tr></table></figure><p>Okay, if most of the program time is taken up by the linker and loading dynamic libraries, let‚Äôs do it statically -&gt; <code>gcc -static prog.cpp -o prog</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.21</span>    msec task-clock:u             #  <span class="number">0.529</span> CPUs utilized</span><br><span class="line"><span class="number">24</span>      page-faults:u                 #  <span class="number">112.888</span> K/sec</span><br><span class="line"><span class="number">123046</span>  cycles:u                      #  <span class="number">0.579</span> GHz</span><br><span class="line"><span class="number">19125</span>   stalled-cycles-frontend:u     #  <span class="number">15.54</span>% frontend cycles idle</span><br><span class="line"><span class="number">10628</span>   stalled-cycles-backend:u      #  <span class="number">8.64</span>% backend cycles idle</span><br><span class="line"><span class="number">26274</span>   instructions:u                #  <span class="number">0.21</span>  insn per cycle</span><br><span class="line">                                      #  <span class="number">0.73</span>  stalled cycles per insn</span><br><span class="line"><span class="number">6775</span>    branches:u                    #  <span class="number">31.867</span> M/sec</span><br><span class="line"><span class="number">690</span>     branch-misses:u               #  <span class="number">10.18</span>% of all branches</span><br><span class="line"></span><br><span class="line"><span class="number">0.000402128</span> seconds time elapsed</span><br></pre></td></tr></table></figure><p>We can see that number of instrucions is decreased 4.26 times. But what is important size increased from <span style="color:green">15776</span> to <span style="color:red">900 224</span> bytes, which is huge difference (<span class="reveal-text" before="x57" after="5706%"></span>). Thats because the library previously used from system is stored in binary code of prog now.<br>Let‚Äôs look at callee list:<br><img src="/2024/09/07/smallest-program/callgrind_list_2.png" alt="callee list"><br>I won‚Äôt paste the glibc library code here for the sake of cleanliness. But as you can see, the __tunables_init function is the main culprit. The main purpose of this function is to allow you to configure the behavior of the glibc library via environment variables. This allows you to customize certain aspects of the library‚Äôs behavior without having to recompile your program. To a certain bare minimum level these variables need to be set because the C runtime doesn‚Äôt know in advance that your program is just blank main function and it won‚Äôt use plural features, so it prepares itself for all possibilities.</p><p>For example there are tunables related to the CPU and memory management. CPU variables such as cache size and thresholds for optimized copy instructions must be set regardless of the actual CPU manufacturer. This explains why functions such as <em>handle_intel</em> and <em>intel_check_word</em> are called even though both my PC and WSL are Ryzen. In part, their total of 19% can be justified by the asking of hardware or system constants</p><p>Equally important are the variables related to memory management, in particular the entire set of glibc.malloc variables. These parameters control key aspects of memory allocation, such as the size and number of memory arenas, the thresholds for using mmap instead of sbrk, and the behavior of the thread cache. For example, glibc.malloc.arena_max can significantly affect memory usage on multi-core systems, while glibc.malloc.mmap_threshold determines when the system will use mmap to allocate larger blocks of memory.</p><p>All tunables you can find <a href="https://www.gnu.org/software/libc/manual/html_node/Tunables.html">here</a> or by calling <code>/lib64/ld-linux-x86-64.so.2 --list-tunables</code></p><p>This is my first technical article, in the next one we will get deeper into C compiled without glibc and the shortest program in asm and its binary. I really appreciate the criticism, so if you have any reservations, leave a comment ‚¨áÔ∏è</p>]]></content>
      
      
      <categories>
          
          <category> Operating System Construction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
            <tag> C </tag>
            
            <tag> libc </tag>
            
            <tag> perf </tag>
            
            <tag> linker </tag>
            
            <tag> programming </tag>
            
            <tag> valgrind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>üåç My Erasmus Experience in Dresden</title>
      <link href="/2024/09/04/erasmus-dresden/"/>
      <url>/2024/09/04/erasmus-dresden/</url>
      
        <content type="html"><![CDATA[<h2 id="üìö-Academic-Pursuits-A-Journey-into-the-Heart-of-Technology"><a href="#üìö-Academic-Pursuits-A-Journey-into-the-Heart-of-Technology" class="headerlink" title="üìö Academic Pursuits: A Journey into the Heart of Technology"></a>üìö Academic Pursuits: A Journey into the Heart of Technology</h2><p>When I decided to go on an Erasmus exchange, I chose Dresden, Germany, for its high academic standards and the opportunity to immerse myself in the German language and culture. Here are the core subjects that shaped my semester:</p><h3 id="1-Operating-System-Construction-OSC"><a href="#1-Operating-System-Construction-OSC" class="headerlink" title="1. Operating System Construction (OSC)"></a>1. <strong>Operating System Construction (OSC)</strong></h3><ul><li><strong>Lectures, Labs, and Exercises</strong>: The subject combined theory and hands-on experience, guided by <em>Operating System Construction</em> by Andrew S. Tanenbaum.</li><li><strong>DIY Operating System</strong>: We designed an OS from the ground up, tackling challenges like schedulers, threads, interrupts, and coroutines. üõ†Ô∏è</li><li><strong>Memorable Takeaway</strong>: The complexity of building a system on bare metal provided a deep understanding of OS fundamentals.</li></ul><h3 id="2-Concurrent-and-Distributed-Systems-CDS"><a href="#2-Concurrent-and-Distributed-Systems-CDS" class="headerlink" title="2. Concurrent and Distributed Systems (CDS)"></a>2. <strong>Concurrent and Distributed Systems (CDS)</strong></h3><ul><li><strong>Course Material</strong>: Based on <em>The Art of Multiprocessor Programming</em> by Maurice Herlihy and Nir Shavit.</li><li><strong>Key Concepts</strong>: Multiprocessor architectures, mutual exclusion, linearizability, atomic registers, consensus, and spin locks. üîÑ</li><li><strong>Highlight</strong>: Learning about the CMPXCHG instruction on x86 processors‚Äîa key element of modern multiprogramming.</li></ul><h3 id="3-Automotive-Software-Engineering"><a href="#3-Automotive-Software-Engineering" class="headerlink" title="3. Automotive Software Engineering"></a>3. <strong>Automotive Software Engineering</strong></h3><ul><li><strong>Focus</strong>: High-level management, methodologies, and technical elements like sensors, connection topology, and ECUs. üöó</li><li><strong>FSD Trip</strong>: Agile workshops and exploring AI in vehicle diagnostics and autonomous driving.</li><li><strong>Guest Lecture</strong>: Insights from the Fraunhofer Institute on sensorics in autonomous vehicles.</li></ul><h2 id="üéâ-Student-Life-A-Thriving-International-Community"><a href="#üéâ-Student-Life-A-Thriving-International-Community" class="headerlink" title="üéâ Student Life: A Thriving International Community"></a>üéâ Student Life: A Thriving International Community</h2><p>Dresden‚Äôs vibrant student life was a pleasant surprise, fueled by the active Erasmus Student Network (ESN).</p><ul><li><strong>Cafe Lingua</strong>: Every Monday, local bars hosted a multilingual meet-up where students could practice languages and meet people from around the world. üó£Ô∏è</li><li><strong>L√§nder Party</strong>: Themed parties every Tuesday celebrated different countries with music, food, and cultural traditions. üåé</li><li><strong>Kultur Buro Campus</strong>: Organized fantastic activities and trips, like the unforgettable excursion to Saxon Switzerland, known for its stunning views. üèûÔ∏è</li></ul><h2 id="üèôÔ∏è-Living-in-Dresden-Costs-Convenience-and-Charm"><a href="#üèôÔ∏è-Living-in-Dresden-Costs-Convenience-and-Charm" class="headerlink" title="üèôÔ∏è Living in Dresden: Costs, Convenience, and Charm"></a>üèôÔ∏è Living in Dresden: Costs, Convenience, and Charm</h2><ul><li><strong>Accommodation</strong>: I lived in a 15-story dormitory on Wundtstrasse, just 2 km from campus, with the amazing SLUB library and two canteens nearby. üè¢</li><li><strong>Cost of Living</strong>: Surprisingly affordable, at around 1.3 to 1.6 times Polish prices, making it easier to manage expenses. üí∂</li><li><strong>Getting Around</strong>: The city was well-connected by trams and bike-friendly, with numerous paths making commuting easy. üö≤</li><li><strong>Green Spaces</strong>: Dresden‚Äôs commitment to green belts and parks added to its charm, providing a refreshing escape from city life. üå≥</li></ul><h2 id="ü§î-Reflecting-on-My-Erasmus-Experience"><a href="#ü§î-Reflecting-on-My-Erasmus-Experience" class="headerlink" title="ü§î Reflecting on My Erasmus Experience"></a>ü§î Reflecting on My Erasmus Experience</h2><p>Choosing Dresden for my Erasmus semester was one of the best decisions I made. It allowed me to advance my technical skills, improved my German, and immerse myself in a new culture. The friendships, knowledge, and memories from this journey are invaluable.</p><p>If you‚Äôre considering Erasmus, I encourage you to look beyond the typical sunny spots and explore options like Dresden, where academic challenges, a lively student scene, and the charm of a unique city await you. üåü</p>]]></content>
      
      
      <categories>
          
          <category> Lifestyle </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
