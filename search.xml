<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The Art of Creating Minimal ELF64 Executables by Unconventional Methods</title>
      <link href="/2024/09/27/3-tiniest-elf/"/>
      <url>/2024/09/27/3-tiniest-elf/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>In the first article, you could see that the simple program:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><p>Was 15776 bytes in size when dynamically linked and 900224 bytes in size when statically linked. Although on today’s computers, these values ​​do not make any impression, still it is surprising that a program that theoretically has several instructions weighs so much. This article delves into the techniques for creating extremely tiny ELF64 (Executable and Linkable Format 64bit) executables on Linux systems.</p><h3 id="C-specifics"><a href="#C-specifics" class="headerlink" title="C specifics"></a>C specifics</h3><p>Unfortunately, in the case of C, the options are quite limited. At some point, we would conclude that it would actually be best to do inline assembly, start the function with _start, and compile with flag -nostdlib and -nostartfiles. For such an application, we could use a lighter library adapted to embedded systems. Like <a href="https://uclibc-ng.org/">uClibc</a>, written for a very limited Linux without MMU or other libraries typically for microcontrollers, such as <a href="https://sourceware.org/newlib/">newlib</a> or its descendant <a href="https://github.com/picolibc/picolibc">picolibc</a>, it still won’t get us as close to a minimal elf64 as asm. </p><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><p>Today, glibc is used in most cases, because most Linux distros contain it. But it wasn’t always like that, Debian used eglibc in the years 2009-2015. The situation was mainly due to the organizational structure of glibc and the fact that it was considered insufficiently adapted to embedded systems or ARM. <a href="https://ecos.sourceware.org/ml/libc-alpha/2002-01/msg00079.html">Here</a> is the correspondence where Linus complains about glibc and calls it “bloated”. I will briefly present the procedure in the case of C and as soon as possible slide into our beloved Assembly.</p><h3 id="How-this-could-differ-to-other-pc"><a href="#How-this-could-differ-to-other-pc" class="headerlink" title="How this could differ to other pc"></a>How this could differ to other pc</h3><p>As the number of executed instructions could be relatively deterministic, the size of the elf file will be very dependent on the machine, installed library versions, and other factors. Of course, going lower and lower with values between different machines, at some point the values will start to be the same, as we get rid of some external dependencies.</p><h3 id="Intel-vs-AT-T-syntax"><a href="#Intel-vs-AT-T-syntax" class="headerlink" title="Intel vs AT&amp;T syntax"></a>Intel vs AT&amp;T syntax</h3><p>At the very beginning, I will state that Assembly has two syntaxes AT&amp;T and Intel, they are completely incompatible, the order of operands, register prefixes, and number prefixes are different. I will use Intel to be compatible with nasm.</p><h2 id="What-steps-we-can-make-in-C-to-reduce-file-size"><a href="#What-steps-we-can-make-in-C-to-reduce-file-size" class="headerlink" title="What steps we can make in C to reduce file size"></a>What steps we can make in C to reduce file size</h2><p>The obvious first step is stripping the executable by adding <code>-s</code> which in our case will remove sections containing symbols .strtab and .symtab which are not needed in execution. After this step <code>-flto</code> will do nothing same as optimizations. The next possible move is to use <code>-Wl,--gc-sections</code> which is just a garbage collector but for sections during the linking process.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">15776</span> default       <span class="comment">// gcc -o default main.c </span></span><br><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">15744</span> flto          <span class="comment">// -flto</span></span><br><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">14328</span> stripped      <span class="comment">// strip --strip-all default</span></span><br><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">14328</span> s             <span class="comment">// -s</span></span><br><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">14328</span> s-o3          <span class="comment">// -s -o3</span></span><br><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">14328</span> s-o3-flto     </span><br><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">14248</span> s-o3-flto-gc  <span class="comment">// -s -o3 -flto -Wl,--gc-sections</span></span><br></pre></td></tr></table></figure><p>These are the simplest techniques, without interfering too much with the program. From a certain point on, it starts to be more of a fight for bytes than writing a program; therefore, if someone is fighting such a fight, it is rather certainly already in Assembly, which we will also do below. For the curious, the next steps without inline asm would be to try to link object files with libraries and disable paging. Also removing unnecessary sections, which would be removed for us by a custom linker script, which would also combine all sections and make one segment.</p><h2 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h2><p>We will jump straight to assembling with nasm and linking with ld to speed up a little. </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start<span class="punctuation">:</span></span><br><span class="line">    mov rax<span class="punctuation">,</span> <span class="number">60</span>    </span><br><span class="line">    mov rdi<span class="punctuation">,</span> <span class="number">1</span>      </span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>after calling <code>nasm -f elf64 small.asm</code> and  <code>ld -s small.o</code> we get:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x <span class="number">1</span> dxr dxr <span class="number">4320</span> a.out</span><br></pre></td></tr></table></figure><p>4320 bytes is a lot for such a small program, especially in asm without library overhead. In the above case, we are using 64 bit registers, changing to ax and di, i.e. 16-bit registers instead of 64-bit rax and rdi, does not make any difference in the output file a.out. Even though by calling <code>objdump -x a.out</code> we can see that the size of the .text section decreases from 12 to 10 bytes. This is because the sections are aligned to 16 bytes &#x3D;&#x3D; 2**4</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sections<span class="punctuation">:</span></span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  <span class="number">0</span> .text         <span class="number">0000000</span>c  <span class="number">0000000000401000</span>  <span class="number">0000000000401000</span>  <span class="number">00001000</span>  <span class="number">2</span>**<span class="number">4</span></span><br><span class="line">                     /\</span><br><span class="line">                     /\</span><br><span class="line">  this value decreases but exe file size does not shrink</span><br></pre></td></tr></table></figure><h2 id="Memory-Alignment-in-Sections-and-Segments"><a href="#Memory-Alignment-in-Sections-and-Segments" class="headerlink" title="Memory Alignment in Sections and Segments"></a>Memory Alignment in Sections and Segments</h2><p>This is because the sections are aligned to 16 bytes &#x3D;&#x3D; 2<strong>4. This means that it doesn’t matter if the value is 2, 12 or 15, this section will have the same size. You may immediately wonder why it is constructed this way and why 2</strong>4 and 2**12, well, read further.</p><p>Let’s look at <code>readelf -lSW a.out</code> it, will show a little bit more info:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Section Headers<span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span>Nr<span class="punctuation">]</span> Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  <span class="punctuation">[</span> <span class="number">0</span><span class="punctuation">]</span>                   NULL            <span class="number">0000000000000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="punctuation">[</span> <span class="number">1</span><span class="punctuation">]</span> .text             PROGBITS        <span class="number">0000000000401000</span> <span class="number">001000</span> <span class="number">000009</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  <span class="punctuation">[</span> <span class="number">2</span><span class="punctuation">]</span> .shstrtab         STRTAB          <span class="number">0000000000000000</span> <span class="number">001009</span> <span class="number">000011</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">Key to Flags<span class="punctuation">:</span></span><br><span class="line">  A (alloc)<span class="punctuation">,</span> X (execute)</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point <span class="number">0x401000</span></span><br><span class="line">There are <span class="number">2</span> program headers<span class="punctuation">,</span> starting at offset <span class="number">64</span></span><br><span class="line"></span><br><span class="line">Program Headers<span class="punctuation">:</span></span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  LOAD           <span class="number">0x000000</span> <span class="number">0x0000000000400000</span> <span class="number">0x0000000000400000</span> <span class="number">0x0000b0</span> <span class="number">0x0000b0</span> R   <span class="number">0x1000</span></span><br><span class="line">  LOAD           <span class="number">0x001000</span> <span class="number">0x0000000000401000</span> <span class="number">0x0000000000401000</span> <span class="number">0x000009</span> <span class="number">0x000009</span> R E <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"> Section to Segment mapping<span class="punctuation">:</span></span><br><span class="line">  Segment Sections...</span><br><span class="line">   <span class="number">00</span></span><br><span class="line">   <span class="number">01</span>     .text</span><br></pre></td></tr></table></figure><p>We see two memory segments typed LOAD, which are intended to be loaded into memory once memory is allocated for them. </p><p>The first one is <span class="reveal-text" before="0xB0" after="176 bytes"></span>. Which mostly holds the ELF header. It will allow the system to identify that it is an elf file or go to the entry point address and the program header, which will be used immediately after to allocate memory space for the segments.</p><p>The second is 9 bytes, which is .text (code) section. Mapped to a segment with 2**12 alignment. We can also see that in addition to the R (READ) flag, there is also an E (Execute) which, together with the fact that the Entry point holds its address and Section to Segment mapping, confirms that this is the code. </p><p>Segments are mapped with 2**12 tonicity, which is a typical 4096 bytes, which is used for paging virtual memory (RAM). It is ideal to choose a value that fits within the page boundaries. Even if there is a bit too much memory redundancy to achieve maximum speed.</p><p>Sections are mapped to segments only for the purpose of loading into memory. Sections and their information are more important to the processor itself, they are made to organize code and data. The .text (code) section will certainly be used very intensively, i.e. it will be placed as close to the CPU as possible. These will be cache memories, which are often paged by 16 bytes. It could also be 4, 8, or 32, but picking the value 16 is a typical alignment on x86_64. It will also mean less memory usage and space savings. The cache memory is valuable, and its optimal use is very significant.</p><h3 id="Modifying-and-removing-alignment"><a href="#Modifying-and-removing-alignment" class="headerlink" title="Modifying and removing alignment"></a>Modifying and removing alignment</h3><p>Linker set the default alignment to 1000 for segments. By calling <code>ld -z max-page-size=0x1 -s small.o</code> we can manipulate this value. But still, the best solution would be to get rid of page alignment altogether. This will provide us with the <code>-n / -nmagic</code> option of calling it combined with strip <code>ld -n -s</code> we get such executable (reduced for clarity):</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Section Headers<span class="punctuation">:</span></span><br><span class="line">  <span class="punctuation">[</span>Nr<span class="punctuation">]</span> Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  <span class="punctuation">[</span> <span class="number">0</span><span class="punctuation">]</span>                   NULL            <span class="number">0000000000000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="punctuation">[</span> <span class="number">1</span><span class="punctuation">]</span> .text             PROGBITS        <span class="number">0000000000400080</span> <span class="number">000080</span> <span class="number">00000</span>a <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  <span class="punctuation">[</span> <span class="number">2</span><span class="punctuation">]</span> .shstrtab         STRTAB          <span class="number">0000000000000000</span> <span class="number">00008</span>a <span class="number">000011</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Entry point <span class="number">0x400080</span></span><br><span class="line">There is <span class="number">1</span> program header<span class="punctuation">,</span> starting at offset <span class="number">64</span></span><br><span class="line"></span><br><span class="line">Program Headers<span class="punctuation">:</span></span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  LOAD           <span class="number">0x000080</span> <span class="number">0x0000000000400080</span> <span class="number">0x0000000000400080</span> <span class="number">0x00000a</span> <span class="number">0x00000a</span> R E <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"> Section to Segment mapping<span class="punctuation">:</span></span><br><span class="line">  Segment Sections...</span><br><span class="line">   <span class="number">00</span>     .text</span><br></pre></td></tr></table></figure><p>By using these steps, we are able to go down to 352 bytes:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> noalg-strip</span><br><span class="line">  352 noalg-strip</span><br></pre></td></tr></table></figure><h3 id="Custom-linker-script"><a href="#Custom-linker-script" class="headerlink" title="Custom linker script"></a>Custom linker script</h3><p>I think this is a good time to mention that we can create our linker script.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = 0x100e8;    // Set location counter </span><br><span class="line">    .all : &#123;</span><br><span class="line">        *(.text*)   // Pack everything into .all section</span><br><span class="line">    &#125; :code </span><br><span class="line">    .shstrtab : &#123; </span><br><span class="line">       *(.shstrtab) // Explanation below</span><br><span class="line">    &#125;</span><br><span class="line">    /DISCARD/ : &#123;   // Discard all other sections</span><br><span class="line">      *(*)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PHDRS</span><br><span class="line">&#123;</span><br><span class="line">  code PT_LOAD FILEHDR PHDRS ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>.</code> section is irrelevant to our program, but we need to specify its address so that the linker knows where to put the headers. </p><h3 id="shstrtab"><a href="#shstrtab" class="headerlink" title=".shstrtab"></a>.shstrtab</h3><p>While trying to remove the .shstrtab section with <code>objcopy --removesection</code> or with <code>strip -R</code> nothing changed. Likewise, GNU Linker (ld) did not respond to discard this section, it just inserted it. LLVM linker (ld.lld), on the other hand, informs us with the following error message: discarding .shstrtab section is not allowed. </p><p>The .shstrtab section is mandatory because the section names are stored as references to this section name table. So as long as there is at least one section in an ELF file, there must be a .shstrtab section.</p><p>This allowed us to go down another 8 bytes:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> noalg-strip-T-super</span><br><span class="line">  344 noalg-strip-T-super</span><br></pre></td></tr></table></figure><h2 id="Why-do-we-need-sections-per-se-then-let’s-try-to-have-some-fun"><a href="#Why-do-we-need-sections-per-se-then-let’s-try-to-have-some-fun" class="headerlink" title="Why do we need sections per se then, let’s try to have some fun."></a>Why do we need sections per se then, let’s try to have some fun.</h2><p><a href="https://uclibc.org/docs/elf-64-gen.pdf">There</a> is a great document that describes the elf64 structure. We can specify that the ELF header is at offset 0x0 and is 64 bytes, and the Program Header is 56 bytes with offset specified in one of EHDR fields, but preferably after EHDR.</p><h3 id="ELF64-Before"><a href="#ELF64-Before" class="headerlink" title="ELF64 Before"></a>ELF64 Before</h3><p><img src="/2024/09/27/3-tiniest-elf/hexyl-before.png" alt="alt text"></p><h3 id="EHDR-fields-needed-for-modification"><a href="#EHDR-fields-needed-for-modification" class="headerlink" title="EHDR fields needed for modification"></a>EHDR fields needed for modification</h3><p>The fields we will need to modify in EHDR are:</p><ul><li>e_entry (Entry point address) now (0x0100f0):<ul><li>Specifies where the _start would be; we set it to 0x400080 right next to PHDR</li></ul></li><li>e_shoff (Section Header Offset) now (0x98):<ul><li>Specifies the offset to the section header table in the file.</li><li>Since we are removing section headers, we set this to 0x0 (no section headers).</li></ul></li><li>e_shentsize (Section Header Entry Size) now (0x40):<ul><li>It determines the size of each section header entry.</li><li>We set the value to 0x0000 (no section headers).</li></ul></li><li>e_shnum (Number of section header entries) now (0x03):<ul><li>This field specifies the number of section header entries.</li><li>We set to 0x0000 (no section headers).</li></ul></li><li>e_shstrndx (Section Name String Table Index) now (0x02):<ul><li>Specifies the index of the section header string table that contains section names.</li><li>Since there are no section headers, we set this value to 0x0 (no string table).</li></ul></li></ul><h3 id="PHDR-fields-needed-for-modification"><a href="#PHDR-fields-needed-for-modification" class="headerlink" title="PHDR fields needed for modification"></a>PHDR fields needed for modification</h3><p>The fields we will need to modify in PHDR are:</p><ul><li>p_offset (Offset in the file) now (0x0):<ul><li>This represents where the segment starts in the file. We will have only one segment with a code, we set it to 0x80</li></ul></li><li>p_vaddr (Virtual address in memory):<ul><li>This is where the segment will be loaded into memory. You can choose a reasonable virtual address, typically aligned, like 0x400080 (just after the headers, matching the p_offset).</li></ul></li><li>p_paddr (Physical address):<ul><li>This is generally ignored for most modern systems, so you can either mirror p_vaddr or set it to 0x0.</li></ul></li><li>p_filesz (Size of the segment in the file):<ul><li>This should be the size of the code segment you’re keeping, not including the ELF header or program header.</li><li>For instance, our code is 10 bytes, we set this to 0xA.</li></ul></li><li>p_memsz (Size of the segment in memory):<ul><li>This should match p_filesz if the segment size in memory is the same as the file size (which is typical for a simple executable).</li><li>The code size is 10 bytes, we set this to 0xA.</li></ul></li></ul><p>We can delete everything that is after our code. </p><h3 id="Final-result"><a href="#Final-result" class="headerlink" title="Final result"></a>Final result</h3><p><img src="/2024/09/27/3-tiniest-elf/hexyl-after.png" alt="alt text"><br>I edited the values using ghex, saved the file. The system has no idea it is an elf64 file and is executable, so we add a flag with the <code>chmod +x</code> command. And we can check if the program works as intended and check the size:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./noalg-strip-T-super-PH-align ; <span class="built_in">echo</span> $?</span><br><span class="line">  1</span><br><span class="line">$ <span class="built_in">wc</span> noalg-strip-T-super-PH-align</span><br><span class="line">  138 noalg-strip-T-super-PH-align</span><br></pre></td></tr></table></figure><h3 id="Removing-alignment"><a href="#Removing-alignment" class="headerlink" title="Removing alignment"></a>Removing alignment</h3><p>This is already very good, recall that EHDR 64 + PHDR 56 &#x3D; 110 with code + 10 &#x3D; 130. Why the remaining 8. That’s because we still did not get rid of alignment.</p><p>We have to change: </p><ul><li>e_entry</li><li>p_offset</li><li>p_vaddr</li><li>p_paddr</li><li>p_align (Alignment of the segment) now(0x10):<ul><li>For minimal alignment, we can use 0x1.</li></ul></li></ul><p><img src="/2024/09/27/3-tiniest-elf/hexyl-noalign.png" alt="alt text"></p><h2 id="Reducing-instruction-size"><a href="#Reducing-instruction-size" class="headerlink" title="Reducing instruction size"></a>Reducing instruction size</h2><p>Now we have only EHDR, PHDR and code, it’s 130 bytes. It’s always the case that if you think something is close to being over, you’re probably halfway through something that someone has already figured out. In computer science, this is a common feeling. So too in this case, still this file can be reduced. It’s not surprising that we can select the exact instructions that have as few bytes as possible in optcode.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old code</span></span><br><span class="line"><span class="number">66</span> b8 <span class="number">3</span>c <span class="number">00</span>   mov    ax<span class="punctuation">,</span><span class="number">0x3c</span></span><br><span class="line"><span class="number">66</span> bf <span class="number">01</span> <span class="number">00</span>   mov    di<span class="punctuation">,</span><span class="number">0x1</span></span><br><span class="line"><span class="number">0</span>f <span class="number">05</span>         syscall</span><br><span class="line"></span><br><span class="line"><span class="comment">// New code</span></span><br><span class="line"><span class="number">31</span> ff         xor    edi<span class="punctuation">,</span>edi</span><br><span class="line"><span class="number">6</span>a <span class="number">3</span>c         push   <span class="number">0x3c</span></span><br><span class="line"><span class="number">58</span>            pop    rax</span><br><span class="line"><span class="number">0</span>f <span class="number">05</span>         syscall</span><br></pre></td></tr></table></figure><p>Just by changing instructions, we are able to cut 3 bytes. Fun fact <code>xor di, di</code> and <code>xor rdi, rdi</code> are 3 bytes, <code>xor edi, edi</code> is the best 2-byte choice. The mov instructions are very expensive, so it makes sense to replace them with a stack. Here it is similar, pop rax is the best choice over other parts of this register.<br><img src="/2024/09/27/3-tiniest-elf/hexyl-noalign-instruction.png" alt="alt text"></p><h2 id="Embedding-the-Code-in-the-ELF-Header"><a href="#Embedding-the-Code-in-the-ELF-Header" class="headerlink" title="Embedding the Code in the ELF Header"></a>Embedding the Code in the ELF Header</h2><p>The ELF64 format does not define where the code and even the Program Header should be. As you can see, of the 16 bytes of the EHDR header, as many as 8 bytes are unused. This is the perfect place to fit our code!<br><img src="/2024/09/27/3-tiniest-elf/hexyl-noalign-instruction-embed.png" alt="alt text"><br>Now we are at 120 bytes and of course while calling <code>readelf -a</code> we will see our code:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -lSaW shortest</span><br><span class="line">  ELF Header<span class="punctuation">:</span></span><br><span class="line">    Magic<span class="punctuation">:</span>   <span class="number">7</span>f <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">31</span> ff <span class="number">6</span>a <span class="number">3</span>c <span class="number">58</span> <span class="number">0</span>f <span class="number">05</span> <span class="number">00</span></span><br><span class="line">    Class<span class="punctuation">:</span>                             ELF64</span><br></pre></td></tr></table></figure><p>but it’s not a problem for readelf to define that it’s ELF64 file.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Delving into the alignment mechanism allowed us to see what memory sacrifices are used today to achieve speed. This could not have happened at once; over the years, as technology progressed, the capacity of specific memories increased, and speed sacrifices may have been made. The techniques presented in this article are more of a curiosity than a guide. Rarely is such a reduction in executable file size needed these days. </p><h3 id="During-the-writing-thoughts"><a href="#During-the-writing-thoughts" class="headerlink" title="During the writing thoughts"></a>During the writing thoughts</h3><p>I had a hard time sensing a line anywhere where I should describe something more broadly and discuss it in detail; I apparently have yet to sense the target audience. Often, too, when exploring a topic and going down with an article, I had to go back up, reworking it after gaining a broader perspective. I’m not sure if the article didn’t come out too long, I had the thought of breaking it into two parts.</p><h2 id="What-next"><a href="#What-next" class="headerlink" title="What next?"></a>What next?</h2><p>In this article I used the expressions “process” and “program” quite interchangeably, in this context it did not have a tremendous meaning, but it will gain importance in my next article in which I will discuss how threads are created, what is clone() fork() execve() or pthread_create().</p><details><summary><span style="color:rgb(0, 152, 241)">Sources</span></summary><ul><li><a href="https://uclibc.org/docs/elf-64-gen.pdf">https://uclibc.org/docs/elf-64-gen.pdf</a></li><li><a href="https://lld.llvm.org/">https://lld.llvm.org/</a></li><li><a href="https://stackoverflow.com/questions/39960434/linux-elf-file-sections-name">https://stackoverflow.com/questions/39960434/linux-elf-file-sections-name</a></li><li><a href="https://stackoverflow.com/questions/65719528/why-is-shstrtab-section-mandatory">https://stackoverflow.com/questions/65719528/why-is-shstrtab-section-mandatory</a></li><li><a href="https://stackoverflow.com/questions/31453859/how-to-remove-a-specific-elf-section-without-stripping-other-symbols">https://stackoverflow.com/questions/31453859/how-to-remove-a-specific-elf-section-without-stripping-other-symbols</a></li><li><a href="https://hackmd.io/@brlin/orncb-ld-manual/https%3A%2F%2Fsourceware.org%2Fbinutils%2Fdocs-2.32%2Fld%2FLocation-Counter.html">https://hackmd.io/@brlin/orncb-ld-manual/https%3A%2F%2Fsourceware.org%2Fbinutils%2Fdocs-2.32%2Fld%2FLocation-Counter.html</a></li><li>Andrew S. Tanenbaum - Modern Operating Systems</details></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> assembly </tag>
            
            <tag> linker </tag>
            
            <tag> libc </tag>
            
            <tag> gcc </tag>
            
            <tag> process </tag>
            
            <tag> executable format </tag>
            
            <tag> elf64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Syscalls Demystified: Understanding the Assembly-Level Mechanics</title>
      <link href="/2024/09/17/2-syscalls-asm-glibc/"/>
      <url>/2024/09/17/2-syscalls-asm-glibc/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>As we saw recently when trying to create the shortest C program. The biggest cost in this program was glibc and its overhead for running the program. How does it look in the case of asm? Today we will see.</p><p>I know how scary assembly is if you’ve only heard about it. But it’s not as scary as they say. I’ll present everything in a very simple way so that everyone can understand what’s going on and who responsible for what.</p><h2 id="What-is-a-syscall"><a href="#What-is-a-syscall" class="headerlink" title="What is a syscall?"></a>What is a syscall?</h2><p>To fully understand what is happening, first I will tell you what is syscall.<br>By default, programs run in user mode, which is a restricted execution environment where the program cannot directly access hardware resources. In user mode, a program does not have direct access I&#x2F;O operations, network access, managing system processes or system files. To interact with it, programs need to communicate with the kernel via kernel mode. </p><h3 id="Syscall-mechanism"><a href="#Syscall-mechanism" class="headerlink" title="Syscall mechanism"></a>Syscall mechanism</h3><p>A system call (syscall) is the mechanism by which a program running in user mode requests services from the kernel. e.g. <em>write()</em> used in <em>prinf()</em> to access stdout or <em>exit()</em> to exit the process. More details and determining the moment at which we switch between modes will be discussed later in this article.</p><p>I will use <em>sys_write</em> and <em>write()</em> to differentiate between the real syscall and the glibc function call.</p><h2 id="Writing-a-program-without-glibc"><a href="#Writing-a-program-without-glibc" class="headerlink" title="Writing a program without glibc"></a>Writing a program without glibc</h2><p>I think now is a good moment to reveal that we can compile a C file without glibc which can be done with flag <code>-nostdlib</code> the fact is, that this program will not be similar to C.</p><h3 id="The-smallest-C-program-without-glibc"><a href="#The-smallest-C-program-without-glibc" class="headerlink" title="The smallest C program without glibc"></a>The smallest C program without glibc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov $60, %rax\n&quot;</span>  </span></span><br><span class="line"><span class="params">        <span class="string">&quot;mov $0, %rdi\n&quot;</span>  </span></span><br><span class="line"><span class="params">        <span class="string">&quot;syscall&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Performance-of-the-program"><a href="#Performance-of-the-program" class="headerlink" title="Performance of the program"></a>Performance of the program</h3><p>This is the performance result of the above code::</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.06</span>   msec task-clock:u            #    <span class="number">0.284</span> CPUs utilized</span><br><span class="line"><span class="number">1</span>      page-faults:u                #    <span class="number">16.743</span> K/sec</span><br><span class="line"><span class="number">1119</span>   cycles:u                     #    <span class="number">0.018</span> GHz</span><br><span class="line"><span class="number">5</span>      stalled-cycles-frontend:u    #    <span class="number">0.45</span>% frontend cycles idle</span><br><span class="line"><span class="number">0</span>      stalled-cycles-backend:u     </span><br><span class="line"><span class="number">6</span>      instructions:u               #    <span class="number">0.01</span>  insn per cycle</span><br></pre></td></tr></table></figure><p>As we can see the result is much better than the last C static linked program, that’s because we don’t need glibc anymore. </p><h2 id="Assembly-Explanation"><a href="#Assembly-Explanation" class="headerlink" title="Assembly Explanation"></a>Assembly Explanation</h2><p>Now time for some assembly, which will explain to us what happened above:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start <span class="comment">// Inform the linker where is program start</span></span><br><span class="line"></span><br><span class="line">_start<span class="punctuation">:</span>           <span class="comment">// Program start</span></span><br><span class="line">    mov rax<span class="punctuation">,</span> <span class="number">60</span>   <span class="comment">// syscall number for exit (60)</span></span><br><span class="line">    mov rdi<span class="punctuation">,</span> <span class="number">0</span>    <span class="comment">// set exit code 0 (rdi = 0)</span></span><br><span class="line">    syscall       <span class="comment">// invoke the system call with syscall number -</span></span><br><span class="line">                  <span class="comment">// stored in rax and exit code in rdi</span></span><br></pre></td></tr></table></figure><p>This is <span class="reveal-text" before="x86-64" after="64 bit"></span> architecture, this is important because code and syscall codes on <span class="reveal-text" before="x86" after="32 bit"></span> are different :D</p><details>  <summary><span style="color:rgb(0, 152, 241)">How it would look on x86</span></summary><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line">    global _start <span class="comment">// Infrom the linker where is program start</span></span><br><span class="line"></span><br><span class="line">_start<span class="punctuation">:</span>            </span><br><span class="line">    mov rax<span class="punctuation">,</span> <span class="number">1</span>   </span><br><span class="line">    mov rdi<span class="punctuation">,</span> <span class="number">0</span>    </span><br><span class="line">    int <span class="number">0x80</span>       </span><br></pre></td></tr></table></figure>By calling *int 0x80* you invoke interrupt and go to x80 address in interrupt handler tablethe 0x80 == 128 is special interrupt programmed only for program system calls</details><br><details>  <summary><span style="color:rgb(0, 152, 241)">How this code became executable</span></summary>Unless like in C's gcc going through pre-processing, compiling, assembling and linking.Assembly doesn't need to be pre-processed or compiled. On linux you can use <span class="reveal-text" before="NASM" after="Netwide Assembler"></span> or <span class="reveal-text" before="AS" after="GNU Assembler"></span> as a assembling tool.I used:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf64 -o exit.o exit.asm </span><br></pre></td></tr></table></figure>where elf64 is format of object file it could be win32The next step is linking <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld exit.o -o exit</span><br></pre></td></tr></table></figure>which is resolving symbols relocating adresses from relative to absolute and making final excutable format, sets up the entry point, the sections (text, data, etc.), and the memory layout necessary for the operating system to run the program.</details><h2 id="Invoking-syscalls-and-register-usage"><a href="#Invoking-syscalls-and-register-usage" class="headerlink" title="Invoking syscalls and register usage"></a>Invoking syscalls and register usage</h2><p>The syscall instruction invokes the syscall with the code contained in the rax register. Then, depending on the code, arguments are required, which are successively passed in rdi, rsi, rdx, r10, r8, r9, this is the convention adopted.</p><h3 id="List-of-syscalls"><a href="#List-of-syscalls" class="headerlink" title="List of syscalls"></a>List of syscalls</h3><p><a href="https://x64.syscall.sh/">Here</a> you can find a list of all syscalls on x86-64 to see what they look like.</p><h3 id="Performance-metrics-of-the-smallest-assembly-program-in-terms-of-instructions"><a href="#Performance-metrics-of-the-smallest-assembly-program-in-terms-of-instructions" class="headerlink" title="Performance metrics of the smallest assembly program in terms of instructions:"></a>Performance metrics of the smallest assembly program in terms of instructions:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.10</span>   msec task-clock:u            #    <span class="number">0.257</span> CPUs utilized</span><br><span class="line"><span class="number">1</span>      page-faults:u                #    <span class="number">9.980</span> K/sec</span><br><span class="line"><span class="number">1289</span>   cycles:u                     #    <span class="number">0.013</span> GHz</span><br><span class="line"><span class="number">5</span>      stalled-cycles-frontend:u    #    <span class="number">0.39</span>% frontend cycles idle</span><br><span class="line"><span class="number">0</span>      stalled-cycles-backend:u</span><br><span class="line"><span class="number">4</span>      instructions:u               #    <span class="number">0.00</span>  insn per cycle</span><br></pre></td></tr></table></figure><h2 id="Where-is-the-actual-entry-point-to-the-program"><a href="#Where-is-the-actual-entry-point-to-the-program" class="headerlink" title="Where is the actual entry point to the program?"></a>Where is the actual entry point to the program?</h2><p>In UNIX-like systems, programs start execution from the <em>_start</em> function. Not the <em>main()</em> function, as we are accustomed to in C. The <em>main()</em> function is essentially a wrapper, like many other components in C. Somewhere within <em>_start</em>, the <em>__libc_start_main</em> function is invoked, followed by a call to main. Here’s a simplified visualization of this process:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_start<span class="punctuation">:</span></span><br><span class="line">    <span class="comment">// rdi already contains argc (passed by kernel)</span></span><br><span class="line">    <span class="comment">// rsi already contains argv (passed by kernel)</span></span><br><span class="line">    <span class="comment">// stack already aligned somewhere</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call main handler</span></span><br><span class="line">    call __libc_start_main</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exit</span></span><br><span class="line">    mov rdi<span class="punctuation">,</span> rax  <span class="comment">// Use main&#x27;s return value as exit status</span></span><br><span class="line">    mov rax<span class="punctuation">,</span> <span class="number">60</span>   <span class="comment">// syscall number for exit</span></span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>If you’re wondering how the return value ends up in the rax register, it’s due to the <a href="https://wiki.osdev.org/System_V_ABI">System V ABI calling convention</a>. This convention dictates how functions pass arguments and return values between each other and the operating system.</p><h2 id="Do-All-Programs-Need-an-Exit"><a href="#Do-All-Programs-Need-an-Exit" class="headerlink" title="Do All Programs Need an Exit?"></a>Do All Programs Need an Exit?</h2><p>What happens if there is no exit system call? Without an explicit exit, the instruction pointer would jump to the next address, fetch the next memory block, and attempt to decode and execute it. This would likely result in a segmentation fault, as the memory would not contain valid executable instructions.</p><p>You might wonder why in C you can write <code>int main()&#123;&#125;</code> without explicitly returning a value or even use <code>void main()&#123;&#125;</code> (which is still accepted for backward compatibility). Surprisingly, the program will compile and execute correctly.</p><p>If you don’t provide a return value, glibc implicitly exits with a 0 code. This behavior is evident when using <em>void main()</em>. We see an exit call is present:<br><img src="/2024/09/17/2-syscalls-asm-glibc/main_no_return.png" alt="exit call in callee list"></p><h3 id="ret-or-sys-exit"><a href="#ret-or-sys-exit" class="headerlink" title="ret or sys_exit"></a>ret or sys_exit</h3><p>The _start function is the entry point, at least for statically linked programs, for dynamically linked programs (if the dynamic loader performs C&#x2F;C++&#x2F;Objective-C startup initialization by including the entry point from crt1.o) it could be the dynamic linker itself. But what is always the same is the Initial Process Stack.<br><img src="/2024/09/17/2-syscalls-asm-glibc/init_process_stack.png" alt="initial process stack"><br>Ret moves the instruction pointer to a return address on the stack, which doesn’t exist here, so calling ret from _start surely will cause a segfault. ret can be called from main (because a new stack frame was created by calling this function) sys_exit or exit() can also be called, which will prevent us from returning to _start.</p><h2 id="glibc’s-Role"><a href="#glibc’s-Role" class="headerlink" title="glibc’s Role"></a>glibc’s Role</h2><p>Saying that three lines of assembly eliminate redundancy in glibc misses the broader context. Glibc acts as an intermediary, making system calls like <em>sys_write</em> easier to use by providing wrappers like direct <em>write()</em> or indirect <em>printf()</em>. It handles details like register saving&#x2F;restoring. While direct assembly skips everything, glibc flushing stdout, thread management, and other necessary actions before the final program exit make it much more than just “redundant code.” Skipping these operations could lead to undefined behavior or even program crashes.</p><p>For example, after calling <em>write()</em>, the program needs to continue executing correctly, so it’s essential to restore the registers to avoid overwriting critical data. This isn’t necessary for <em>sys_exit</em> because it clobbers some of the registers and changes context anyway, it’s crucial for other syscalls where the program continues running.</p><p>There is  also syscall(), a small library function that invokes the system call whose assembly language interface has the specified number with the specified arguments.  Employing syscall() is useful, for example, when invoking a system call that has no wrapper function in the C library. It provides saving, restoring registers and returning an error, which is always a better solution than a syscall in direct Assembly.</p><h3 id="Glibc-glibc-libc-is-there-sth-other"><a href="#Glibc-glibc-libc-is-there-sth-other" class="headerlink" title="Glibc, glibc, libc is there sth other?"></a>Glibc, glibc, libc is there sth other?</h3><p><a href="https://musl.libc.org/">Musl</a> is a smaller alternative to glibc (7x smaller), and it’s more common to see inline assembly syscalls used there. However, glibc’s complexity supports more features and safer execution. Hope I’ll write something more about it someday.</p><h2 id="Vicious-circle"><a href="#Vicious-circle" class="headerlink" title="Vicious circle"></a>Vicious circle</h2><p>What’s funny is that glibc itself is not able to call any syscall using C because it doesn’t have direct access to registers. For that, you need an assembler, which will probably be somewhere in the depths of glibc. Calling syscall in assembly causes an interrupt; the system goes into kernel mode and uses IDT to determine how to process a specific interrupt; finally, the interrupt goes to entry_64.S, which will pass control to the appropriate handler written in C via syscall_table, where there is usually something like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>Then the appropriate function, e.g. sys_write, can be used. As you can see, it goes full circle C-&gt;assembly-&gt;C where the return of syscall code will look similarly to the sysret called in assembly.</p><h2 id="Is-it-worth-it"><a href="#Is-it-worth-it" class="headerlink" title="Is it worth it?"></a>Is it worth it?</h2><p>Today, going down to assembly is rarely justified when embedded devices have developed so much, where memory is no longer so limited, and clock speeds have increased so much that time is also no longer an issue. However, it is always worth being aware of how it works “under the hood”.</p><h2 id="What-next"><a href="#What-next" class="headerlink" title="What next?"></a>What next?</h2><p>The next article will mainly cover the size of the executable itself, the construction of the elf64 file, how the system reads and executes it, and probably how to construct it by yourself.</p><p>I really appreciate any feedback, so if you have any comments or suggestions, feel free to leave a comment below ⬇️.</p>]]></content>
      
      
      <categories>
          
          <category> Operating System Construction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> perf </tag>
            
            <tag> assembly </tag>
            
            <tag> linker </tag>
            
            <tag> libc </tag>
            
            <tag> gcc </tag>
            
            <tag> syscall </tag>
            
            <tag> process </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>From Instruction Count to Clock Cycles: Exploring the Performance of Minimal C Program</title>
      <link href="/2024/09/07/1-smallest-c-prog/"/>
      <url>/2024/09/07/1-smallest-c-prog/</url>
      
        <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>I was wondering how big the overhead is before and&#x2F;or after program execution. It was unreasonable to start with anything other than the simplest program with a blank <code>main</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><p>Theoretically, it is possible to compile a void main in C, which would remove the return value. However, that is not valid according to the ISO standard (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">C++ §3.6.1&#x2F;2</a> | <a href="https://www.open-std.org/JTC1/sc22/WG14/www/docs/n2310.pdf">C §5.1.2.2&#x2F;1</a>). So we will skip it.</p><p>When we try to disassemble this code, we get an assembly with 5 instructions:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push    rbp      <span class="comment">// push base pointer on stack to stabilize stack frame</span></span><br><span class="line">mov     rbp, rsp <span class="comment">// set base pointer on local stack pointer</span></span><br><span class="line">mov     eax, <span class="number">1</span>   <span class="comment">// eax commonly stores the function return value set it to 1</span></span><br><span class="line">pop     rbp      <span class="comment">// close the stack frame</span></span><br><span class="line">ret              <span class="comment">// return form procedure</span></span><br></pre></td></tr></table></figure><p>Technically speaking, stack and stack pointer operations are not needed in this context, so the code could be reduced to:</p><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, <span class="number">1</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Now, guess how many instructions it takes to execute the above program. The answer is <span class="reveal-text" before="???" after="112 047"></span>.<br>This value is hard to believe, considering that the program itself is just 5 instructions. We will try to find out what and why this happens.</p><h2 id="Analysis-Tools"><a href="#Analysis-Tools" class="headerlink" title="Analysis Tools"></a>Analysis Tools</h2><p>Mainly, two tools will be used for the analysis <code>valgrind --tool=callgrind</code> and <code>perf</code>. For visualization, I used Callgrind because of its GUI tool and the greater clarity of the results. The most important factor I chose was instruction count because it is machine-independent and deterministic. The runtime environment doesn’t have to be exactly the same to perform profiling, which is not true for cycles and especially for execution time.</p><h2 id="Callgrind-Call-Map-Call-List-of-dynamically-linked-program"><a href="#Callgrind-Call-Map-Call-List-of-dynamically-linked-program" class="headerlink" title="Callgrind Call Map &amp; Call List of dynamically linked program"></a>Callgrind Call Map &amp; Call List of dynamically linked program</h2><p><img src="/2024/09/07/1-smallest-c-prog/callgrind_graph_1.png" alt="callgrind call map"><br><img src="/2024/09/07/1-smallest-c-prog/callgrind_list_1.png" alt="callgrind call list"><br>As we can see, 98.22% of instructions were made outside the program. In ld-linux-x86-64.so which is a dynamic Linux linker <span class="reveal-text" before="DLL" after="dynamic library"></span>. We see methods like <em>_dl_sysdep_start</em>, <em>dl_start</em>, <em>dl_main</em>, <em>dl_relocate_object</em>, <em>dl_lookup_symbol_x</em>. These are part of the dynamic loading process. Their goal is to load, init, relocate and <span class="reveal-text" before="resolve symbols" after="find function and variables names"></span>used in prog contained, for example in libc.so. Later, we can see <em>handle_amd</em> or <em>handle_intel</em> are involved in the initialization and detection of specific processor functions (like SSE extension support, AVX, etc.). Even if your program does not use these functions directly, the system must initialize the CPU to adapt to the appropriate hardware environment. </p><h2 id="Running-perf-stat-of-static-dynamic-approach-comparison"><a href="#Running-perf-stat-of-static-dynamic-approach-comparison" class="headerlink" title="Running perf stat of static &amp; dynamic approach comparison"></a>Running perf stat of static &amp; dynamic approach comparison</h2><p>Let’s run <code>perf stat</code> to have some unified result to compare it later</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.42</span>    msec task-clock:u              #  <span class="number">0.571</span> CPUs utilized</span><br><span class="line"><span class="number">48</span>      page-faults:u                  #  <span class="number">115.551</span> K/sec</span><br><span class="line"><span class="number">331515</span>  cycles:u                       #  <span class="number">0.798</span> GHz</span><br><span class="line"><span class="number">16380</span>   stalled-cycles-frontend:u      #  <span class="number">4.94</span>% frontend cycles idle</span><br><span class="line"><span class="number">1911</span>    stalled-cycles-backend:u       #  <span class="number">0.58</span>% backend cycles idle</span><br><span class="line"><span class="number">112047</span>  instructions:u                 #  <span class="number">0.34</span>  insn per cycle</span><br><span class="line">                                       #  <span class="number">0.15</span>  stalled cycles per insn</span><br><span class="line"><span class="number">22072</span>   branches:u                     #  <span class="number">53.134</span> M/sec</span><br><span class="line"><span class="number">1830</span>    branch-misses:u                #  <span class="number">8.29</span>% of all branches</span><br><span class="line"></span><br><span class="line"><span class="number">0.000727095</span> seconds time elapsed</span><br></pre></td></tr></table></figure><p>Okay, if most of the program time is taken up by the linker and loading dynamic libraries, let’s do it statically -&gt; <code>gcc -static prog.cpp -o prog</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.21</span>    msec task-clock:u             #  <span class="number">0.529</span> CPUs utilized</span><br><span class="line"><span class="number">24</span>      page-faults:u                 #  <span class="number">112.888</span> K/sec</span><br><span class="line"><span class="number">123046</span>  cycles:u                      #  <span class="number">0.579</span> GHz</span><br><span class="line"><span class="number">19125</span>   stalled-cycles-frontend:u     #  <span class="number">15.54</span>% frontend cycles idle</span><br><span class="line"><span class="number">10628</span>   stalled-cycles-backend:u      #  <span class="number">8.64</span>% backend cycles idle</span><br><span class="line"><span class="number">26274</span>   instructions:u                #  <span class="number">0.21</span>  insn per cycle</span><br><span class="line">                                      #  <span class="number">0.73</span>  stalled cycles per insn</span><br><span class="line"><span class="number">6775</span>    branches:u                    #  <span class="number">31.867</span> M/sec</span><br><span class="line"><span class="number">690</span>     branch-misses:u               #  <span class="number">10.18</span>% of all branches</span><br><span class="line"></span><br><span class="line"><span class="number">0.000402128</span> seconds time elapsed</span><br></pre></td></tr></table></figure><p>We can see that the number of instructions has decreased 4.26 times. However, the binary size increased from <span style="color:green">15776</span> to <span style="color:red">900 224</span> bytes, which is a huge difference (<span class="reveal-text" before="x57" after="5706%"></span>). This is because the libraries that were previously dynamically linked to the system are now stored in the binary code of the program.</p><h2 id="Callee-List-of-statically-linked-program"><a href="#Callee-List-of-statically-linked-program" class="headerlink" title="Callee List of statically linked program"></a>Callee List of statically linked program</h2><p><img src="/2024/09/07/1-smallest-c-prog/callgrind_list_2.png" alt="callee list"><br>I won’t paste the glibc library code here for the sake of cleanliness. But as you can see, the __tunables_init function is the main culprit. The main purpose of this function is to allow you to configure the behavior of the glibc library via environment variables. This allows you to customize certain aspects of the library’s behavior without having to recompile your program. A minimum set of these variables must be initialized because the C runtime doesn’t know in advance that your program is just a blank main function and won’t use most features, so it prepares for all possibilities.</p><h2 id="CPU-and-Memory-Tunables"><a href="#CPU-and-Memory-Tunables" class="headerlink" title="CPU and Memory Tunables"></a>CPU and Memory Tunables</h2><p>For example, there are tunables related to the CPU and memory management. CPU variables such as cache size and thresholds for optimized copy instructions must be set, regardless of the actual CPU manufacturer. This explains why functions such as <em>handle_intel</em> and <em>intel_check_word</em> are called, even though both my PC and WSL are Ryzen. Their total of 19% can be partly justified by querying hardware or system constants.</p><p>Equally important are the variables related to memory management, particularly the entire set of glibc.malloc variables. These parameters control key aspects of memory allocation, such as the size and number of memory arenas, the thresholds for using mmap instead of sbrk, and the behavior of the thread cache. For example, glibc.malloc.arena_max can significantly affect memory usage on multi-core systems, while glibc.malloc.mmap_threshold determines when the system will use mmap to allocate larger blocks of memory.</p><p>All tunables you can find <a href="https://www.gnu.org/software/libc/manual/html_node/Tunables.html">here</a> or by calling <code>/lib64/ld-linux-x86-64.so.2 --list-tunables</code></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This is my first technical article. It was intended to illustrate the differences between dynamic and static linking, more or less show the costs and benefits of each, and explain why it happens and what is responsible for it.</p><p> In the next one, we will dive deeper into C compiled without glibc and explore the shortest program in assembly and its binary. I really appreciate any feedback, so if you have any comments or suggestions, feel free to leave a comment below ⬇️.</p>]]></content>
      
      
      <categories>
          
          <category> Operating System Construction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> programming </tag>
            
            <tag> valgrind </tag>
            
            <tag> perf </tag>
            
            <tag> assembly </tag>
            
            <tag> linker </tag>
            
            <tag> libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🌍 My Erasmus Experience in Dresden</title>
      <link href="/2024/09/04/0-erasmus-dresden/"/>
      <url>/2024/09/04/0-erasmus-dresden/</url>
      
        <content type="html"><![CDATA[<h2 id="📚-Academic-Pursuits-A-Journey-into-the-Heart-of-Technology"><a href="#📚-Academic-Pursuits-A-Journey-into-the-Heart-of-Technology" class="headerlink" title="📚 Academic Pursuits: A Journey into the Heart of Technology"></a>📚 Academic Pursuits: A Journey into the Heart of Technology</h2><p>When I decided to go on an Erasmus exchange, I chose Dresden, Germany, for its high academic standards and the opportunity to immerse myself in the German language and culture. Here are the core subjects that shaped my semester:</p><h3 id="1-Operating-System-Construction-OSC"><a href="#1-Operating-System-Construction-OSC" class="headerlink" title="1. Operating System Construction (OSC)"></a>1. <strong>Operating System Construction (OSC)</strong></h3><ul><li><strong>Lectures, Labs, and Exercises</strong>: The subject combined theory and hands-on experience, guided by <em>Operating System Construction</em> by Andrew S. Tanenbaum.</li><li><strong>DIY Operating System</strong>: We designed an OS from the ground up, tackling challenges like schedulers, threads, interrupts, and coroutines. 🛠️</li><li><strong>Memorable Takeaway</strong>: The complexity of building a system on bare metal provided a deep understanding of OS fundamentals.</li></ul><h3 id="2-Concurrent-and-Distributed-Systems-CDS"><a href="#2-Concurrent-and-Distributed-Systems-CDS" class="headerlink" title="2. Concurrent and Distributed Systems (CDS)"></a>2. <strong>Concurrent and Distributed Systems (CDS)</strong></h3><ul><li><strong>Course Material</strong>: Based on <em>The Art of Multiprocessor Programming</em> by Maurice Herlihy and Nir Shavit.</li><li><strong>Key Concepts</strong>: Multiprocessor architectures, mutual exclusion, linearizability, atomic registers, consensus, and spin locks. 🔄</li><li><strong>Highlight</strong>: Learning about the CMPXCHG instruction on x86 processors—a key element of modern multiprogramming.</li></ul><h3 id="3-Automotive-Software-Engineering"><a href="#3-Automotive-Software-Engineering" class="headerlink" title="3. Automotive Software Engineering"></a>3. <strong>Automotive Software Engineering</strong></h3><ul><li><strong>Focus</strong>: High-level management, methodologies, and technical elements like sensors, connection topology, and ECUs. 🚗</li><li><strong>FSD Trip</strong>: Agile workshops and exploring AI in vehicle diagnostics and autonomous driving.</li><li><strong>Guest Lecture</strong>: Insights from the Fraunhofer Institute on sensorics in autonomous vehicles.</li></ul><h2 id="🎉-Student-Life-A-Thriving-International-Community"><a href="#🎉-Student-Life-A-Thriving-International-Community" class="headerlink" title="🎉 Student Life: A Thriving International Community"></a>🎉 Student Life: A Thriving International Community</h2><p>Dresden’s vibrant student life was a pleasant surprise, fueled by the active Erasmus Student Network (ESN).</p><ul><li><strong>Cafe Lingua</strong>: Every Monday, local bars hosted a multilingual meet-up where students could practice languages and meet people from around the world. 🗣️</li><li><strong>Länder Party</strong>: Themed parties every Tuesday celebrated different countries with music, food, and cultural traditions. 🌎</li><li><strong>Kultur Buro Campus</strong>: Organized fantastic activities and trips, like the unforgettable excursion to Saxon Switzerland, known for its stunning views. 🏞️</li></ul><h2 id="🏙️-Living-in-Dresden-Costs-Convenience-and-Charm"><a href="#🏙️-Living-in-Dresden-Costs-Convenience-and-Charm" class="headerlink" title="🏙️ Living in Dresden: Costs, Convenience, and Charm"></a>🏙️ Living in Dresden: Costs, Convenience, and Charm</h2><ul><li><strong>Accommodation</strong>: I lived in a 15-story dormitory on Wundtstrasse, just 2 km from campus, with the amazing SLUB library and two canteens nearby. 🏢</li><li><strong>Cost of Living</strong>: Surprisingly affordable, at around 1.3 to 1.6 times Polish prices, making it easier to manage expenses. 💶</li><li><strong>Getting Around</strong>: The city was well-connected by trams and bike-friendly, with numerous paths making commuting easy. 🚲</li><li><strong>Green Spaces</strong>: Dresden’s commitment to green belts and parks added to its charm, providing a refreshing escape from city life. 🌳</li></ul><h2 id="🤔-Reflecting-on-My-Erasmus-Experience"><a href="#🤔-Reflecting-on-My-Erasmus-Experience" class="headerlink" title="🤔 Reflecting on My Erasmus Experience"></a>🤔 Reflecting on My Erasmus Experience</h2><p>Choosing Dresden for my Erasmus semester was one of the best decisions I made. It allowed me to advance my technical skills, improved my German, and immerse myself in a new culture. The friendships, knowledge, and memories from this journey are invaluable.</p><p>This journey, and specifically the fascinating subject of OSC, indirectly prompted me to create a blog for it.</p><p>If you’re considering Erasmus, I encourage you to look beyond the typical sunny spots and explore options like Dresden, where academic challenges, a lively student scene, and the charm of a unique city await you. 🌟</p>]]></content>
      
      
      <categories>
          
          <category> Lifestyle </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
